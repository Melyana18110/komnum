<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="None">
        
        
        <link rel="shortcut icon" href="img/favicon.ico">
        <title>My Docs</title>
        <link href="css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="css/font-awesome.min.css" rel="stylesheet">
        <link href="css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="js/jquery-1.10.2.min.js" defer></script>
        <script src="js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body class="homepage">

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <a class="navbar-brand" href=".">My Docs</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#tugas-komputasi-numerik">Tugas Komputasi Numerik</a></li>
            <li><a href="#deret-maclaurin">DERET MACLAURIN</a></li>
            <li><a href="#program-newton-raphson-pada-fungsi-non-linear">Program Newton Raphson pada Fungsi Non Linear</a></li>
            <li><a href="#eliminasi-gauss-jordan">Eliminasi Gauss Jordan</a></li>
            <li><a href="#recursive-trapezoid">Recursive Trapezoid</a></li>
            <li><a href="#richardson-extrapolation">Richardson Extrapolation</a></li>
            <li><a href="#metode-euler">Metode Euler</a></li>
            <li><a href="#monte-carlo">Monte Carlo</a></li>
            <li><a href="#ujian-akhir-semester">Ujian Akhir Semester</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="tugas-komputasi-numerik">Tugas Komputasi Numerik</h1>
<p>Nama  : Melyana Febrianti</p>
<p>NIM     : 180411100110</p>
<p>Mata Kuliah : Komputasi Numerik 4A</p>
<h2 id="deret-maclaurin">DERET MACLAURIN</h2>
<p>​       Adalah Suatu fungsi f(x) yang memiliki turunan <img alt="f'(x)" src="https://s0.wp.com/latex.php?latex=f%27%28x%29&amp;bg=ffffff&amp;fg=666666&amp;s=0" />, <img alt="f''(x)" src="https://s0.wp.com/latex.php?latex=f%27%27%28x%29&amp;bg=ffffff&amp;fg=666666&amp;s=0" />, <img alt="f'''(x)" src="https://s0.wp.com/latex.php?latex=f%27%27%27%28x%29&amp;bg=ffffff&amp;fg=666666&amp;s=0" />, dan seterusnya yang kontinyu dalam interval <img alt="I" src="https://s0.wp.com/latex.php?latex=I&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> dengan <img alt="a, x \in I" src="https://s0.wp.com/latex.php?latex=a%2C+x+%5Cin+I&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> maka untuk <img alt="x" src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> disekitar <img alt="a" src="https://s0.wp.com/latex.php?latex=a&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> yaitu <img alt="|x -a| &lt; \mathbb{R}" src="https://s0.wp.com/latex.php?latex=%7Cx+-a%7C+%3C+%5Cmathbb%7BR%7D&amp;bg=ffffff&amp;fg=666666&amp;s=0" />, <img alt="f(x)" src="https://s0.wp.com/latex.php?latex=f%28x%29&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> dapat diekspansi kedalam Deret Taylor.</p>
<p>​       Sebenarnya deret MacLaurin masih berhubungan erat dengan Deret Taylor. Deret MacLaurin merupaan kasus khusus dari deret Taylor yaitu deret taylor dengan fungsi yang di ekspansi di sekitar c=0. Deret MacLaurin disebut juga sebagai <strong>Deret Taylor Baku</strong></p>
<ul>
<li>Formula Deret MacLaurin :</li>
</ul>
<p><img alt="f(x) = f(0) + \dfrac{x}{1!} f'(0) + \dfrac{x^2}{2!} f''(0) + \ldots + \dfrac{x^n}{n!} f^{(n)}(0) + \ldots + R_n(x)" src="https://s0.wp.com/latex.php?latex=f%28x%29+%3D+f%280%29+%2B+%5Cdfrac%7Bx%7D%7B1%21%7D+f%27%280%29+%2B+%5Cdfrac%7Bx%5E2%7D%7B2%21%7D+f%27%27%280%29+%2B+%5Cldots+%2B+%5Cdfrac%7Bx%5En%7D%7Bn%21%7D+f%5E%7B%28n%29%7D%280%29+%2B+%5Cldots+%2B+R_n%28x%29&amp;bg=ffffff&amp;fg=666666&amp;s=0" /></p>
<ul>
<li>atau bisa dinyatakan dengan :</li>
</ul>
<p><img alt="= \displaystyle \sum_{n=0}^{\infty} \dfrac{1}{n!} x^n" src="https://s0.wp.com/latex.php?latex=%3D+%5Cdisplaystyle+%5Csum_%7Bn%3D0%7D%5E%7B%5Cinfty%7D+%5Cdfrac%7B1%7D%7Bn%21%7D+x%5En&amp;bg=ffffff&amp;fg=666666&amp;s=0" /></p>
<p>​ Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718...</p>
<ul>
<li>
<p><strong>SOAL</strong></p>
<p>tentukan e2x dengan x = 4 dan ekspansi eror &lt; 0,001.</p>
<p>f(x) = (e)^2x <img alt="\rightarrow" src="https://s0.wp.com/latex.php?latex=%5Crightarrow&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> f(0) = 1</p>
<p>f'(x) = (2e)^2x <img alt="\rightarrow" src="https://s0.wp.com/latex.php?latex=%5Crightarrow&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> f'(0) = 2</p>
<p>f”(x) = (4e)^2x <img alt="\rightarrow" src="https://s0.wp.com/latex.php?latex=%5Crightarrow&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> f”(0) = 4</p>
<p>f”'(x) = (8e)^2x <img alt="\rightarrow" src="https://s0.wp.com/latex.php?latex=%5Crightarrow&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> f”'(0) = 8</p>
<p>f””(x) = (16e)^2x <img alt="\rightarrow" src="https://s0.wp.com/latex.php?latex=%5Crightarrow&amp;bg=ffffff&amp;fg=666666&amp;s=0" /> f””(0) = 16</p>
</li>
<li>
<p><strong>Program</strong></p>
</li>
</ul>
<pre><code class="python">import math

x=4
cek =1
a = 0
b=1
iter = 1

while cek&gt;0.001:
    f_x = 0
    f_y = 0
    for i in range(a):
        f_x += (2**i)*x**i/math.factorial(i)

    for j in range(b):
        f_y += (2**j)*x**j/math.factorial(j)
    cek = f_y-f_x
    a+=1
    b+=1
    print(&quot;iterasi ke-&quot;,iter,&quot;= &quot;,cek)
    iter+=1
</code></pre>

<pre><code class="python">iterasi ke- 1 =  1.0
iterasi ke- 2 =  8.0
iterasi ke- 3 =  32.0
iterasi ke- 4 =  85.33333333333333
iterasi ke- 5 =  170.66666666666669
iterasi ke- 6 =  273.0666666666666
iterasi ke- 7 =  364.08888888888896
iterasi ke- 8 =  416.1015873015872
iterasi ke- 9 =  416.1015873015872
iterasi ke- 10 =  369.8680776014112
iterasi ke- 11 =  295.89446208112895
iterasi ke- 12 =  215.195972422639
iterasi ke- 13 =  143.46398161509296
iterasi ke- 14 =  88.28552714774924
iterasi ke- 15 =  50.448872655856576
iterasi ke- 16 =  26.90606541645684
iterasi ke- 17 =  13.45303270822842
iterasi ke- 18 =  6.330838921519444
iterasi ke- 19 =  2.8137061873417224
iterasi ke- 20 =  1.184718394670199
iterasi ke- 21 =  0.47388735786807956
iterasi ke- 22 =  0.18052851728316455
iterasi ke- 23 =  0.06564673355751438
iterasi ke- 24 =  0.022833646454728296
iterasi ke- 25 =  0.0076112154847578495
iterasi ke- 26 =  0.0024355889549951826
iterasi ke- 27 =  0.0007494119863622473
</code></pre>

<h2 id="program-newton-raphson-pada-fungsi-non-linear">Program Newton Raphson pada Fungsi Non Linear</h2>
<p>​   Newton Raphson Adalah metode pencarian akar suatu fungsi <em>f(x)</em> dengan pendekatan satu titik, dimana fungsi <em>f(x)</em> mempunyai turunan. Metode ini dianggap lebih mudah dari <strong>Metode Bagi Dua</strong> (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya.</p>
<p>​   Menentukan <em>x0</em> sebagai titik awal, kemudian menarik garis lurus (misal garis ıı ) yang menyinggung titik <em>f(x0)</em> . Hal ini berakibat garis ıı memotong sumbu <em>x</em> di titik <em>x1</em> Setelah itu diulangi langkah sebelumnya tapi sekarang <em>x1</em> dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan <em>x2,x3,...,xnx2,x3,...,xn</em> dengan <em>xn</em> yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya.</p>
<p>persamaan garis <em>ı:y−y0=m(x−x0)</em></p>
<p><em>y−f(x0)=f′(x0)(x−x0)</em></p>
<p><em>x1</em> perpotongan garis ıı dengan sumbu - <em>x</em></p>
<p>0−f(x0)=f′(x0)(x−x0)</p>
<p><em>y = 0</em> dan <em>x = x1</em> maka koordinat titik (<em>x1</em>,0)</p>
<p>−f(x0)/f′(x0)=(x1−x0)</p>
<p>sehingga di dapat sebuah rumus :</p>
<p>x1=x0−f(x0)/f′(x0),x2=x1−f(x1)/f′(x1),...,xn=xn−1−f(xn−1)/f′(xn−1)</p>
<p><strong>Menyusun Algoritma dan Pemrograman Newton Rhapson</strong></p>
<p>​       Dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar <em>f(x)=0</em> sebagai berikut :</p>
<ol>
<li>Didefinisikan fungsi <em>f</em> dengan <em>f(x)</em> dan <em>f′(x)</em></li>
<li>Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk <em>Stopping Condition</em></li>
<li>Dipilih tebakan awal <em>x0</em></li>
<li>Dihitung <em>f(x0)</em> dan <em>f'(x0)</em></li>
<li>Dihitung <em>xb=x0−f(x0)f′(x0)≠0</em> . jika <em>f′(x0)=0</em> kembali ke langkah - 3</li>
<li>Jika <em>|xb−x0|&lt;ε</em> . itersasi lebih dari iterasi maksimum tulis <em>xhampiran=xbxhampiran=xb</em> sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya.</li>
<li>Ganti nilai <em>x0</em> dengan <em>x0=xb</em> dan kembali ke langkah-4</li>
</ol>
<p><strong>Program</strong></p>
<pre><code class="python">import math
e = 2.71828

def fungsi(x):
    x = float((e**x) - (4*x))
    return x
def fungsiturunan(x):
    x = float((e**x) - (4))
    return x

x = float(input('Masukkan nilai awal = '))
error = float(input('Masukkan nilai error = '))
perulangan = int(input('Masukkan maksimal pengulangan = '))

iterasi = 0
selisih = error+1
while iterasi &lt;= perulangan  and selisih&gt;error :
    iterasi += 1
    f_2 = x - (fungsi(x)/fungsiturunan(x))
    selisih = math.fabs(f_2 - x)
    x = f_2
    print(&quot;Iterasi ke&quot;,iterasi,&quot;x = &quot;,f_2, &quot;, f(&quot;,f_2,&quot;) = &quot;,fungsi(f_2),&quot;, selisih = &quot;,error)
    if iterasi &lt;= perulangan:
        print(&quot;Perulangan Mencapai Batas Maksimal dengan hasil = &quot;, f_2)
    else :
        print(&quot;Toleransi tidak terpenuhi&quot;)
</code></pre>

<pre><code class="python">Masukkan nilai awal = 0
Masukkan nilai error = 0.0001
Masukkan maksimal pengulangan = 10
Iterasi ke 1 x =  0.3333333333333333 , f( 0.3333333333333333 ) =  0.06227877883196098 , selisih =  0.0001
Perulangan Mencapai Batas Maksimal dengan hasil =  0.3333333333333333
Iterasi ke 2 x =  0.35724635301940616 , f( 0.35724635301940616 ) =  0.0004022049593612742 , selisih =  0.0001
Perulangan Mencapai Batas Maksimal dengan hasil =  0.35724635301940616
Iterasi ke 3 x =  0.35740281572145605 , f( 0.35740281572145605 ) =  1.734656973617632e-08 , selisih =  0.0001
Perulangan Mencapai Batas Maksimal dengan hasil =  0.35740281572145605
Iterasi ke 4 x =  0.3574028224700733 , f( 0.3574028224700733 ) =  -6.439293542825908e-15 , selisih =  0.0001
Perulangan Mencapai Batas Maksimal dengan hasil =  0.3574028224700733
</code></pre>

<p><strong>Penjelasan dari program diatas</strong></p>
<ol>
<li>Importh Library math</li>
<li>karena kita menggunakan contoh fungsi <em>f(x)=ex−4X</em> maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu <em>f′(x)=ex−4</em></li>
<li>Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition</li>
<li>lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan</li>
<li>deklarasikan selisih untuk <em>xb−x0</em> untuk perbandingan</li>
<li>lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon</li>
<li>hitung <em>xb</em> dengan rumus yang sudah kita dapatkan sebelumnya</li>
<li>lalu lakukan perbandingan jika mencapai nilai <em>True</em> maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas</li>
<li>jika pengecekan selisih &gt; error bernilai bernilai <em>True</em> maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n</li>
</ol>
<h2 id="eliminasi-gauss-jordan">Eliminasi Gauss Jordan</h2>
<p>​       Metode ini pengembangan dari metode eliminasi gauss. Dimana tujuan kita membuat matriks identitas bukan lagi segitiga atas sehingga tidak diperlukan lagi subtitusi balik untuk mencari nilai dari akar persamaan. Eliminasi Gauss-Jordan adalah pengembangan dari eliminasi Gauss yang hasilnya lebih sederhanalagi. Caranya adalah dengan meneruskan operasi baris dari eliminasi Gauss sehingga menghasilkan matriks yang Eselon-baris. Ini juga dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks.</p>
<p>Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.</p>
<p><img alt="" src="gauss.png" /></p>
<p><strong>Algoritma Metode Eliminasi Gauss adalah:</strong></p>
<ol>
<li>
<p>Masukkan matrik A, dan vektor B beserta ukurannya n</p>
</li>
<li>
<p>Buat augmented matrik [A|B] namakan dengan A</p>
</li>
<li>
<p>Untuk baris ke i dimana i=1 s/d n, perhatikan apakah nilai ai,i =0 :</p>
</li>
</ol>
<p>Bila ya : pertukarkan baris ke i dan baris ke i+k≤n, dimana ai+k ,i ≠0, bila tidak ada berarti perhitungan tidak bisa dilanjutkan dan proses dihentikan dengan tanpa penyelesaian. Bila tidak : Untuk baris ke j, dimana j = i+1 s/d n</p>
<p><strong>Program</strong></p>
<pre><code class="python">import numpy as np

#Definisi Matrix
A = []
B = []

n = int(input(&quot;Masukkan ukuran Matrix: &quot;))
for i in range(n):
    baris=[]
    for i in range(n):
        a=int(input(&quot;Masukkan Nilai: &quot;))
        baris.append(a)
    A.append(baris)
for i in range(n):
    h = int(input(&quot;Masukkan Hasil: &quot;))
    B.append(h)

Matrix=np.array(A,float)
Hasil=np.array(B,float)

n=len(Matrix)


#Eliminasi Gauss

for k in range(0,n-1):
    for i in range(k+1,n):
        if Matrix[i,k]!=0 :
            lam=Matrix[i,k]/Matrix[k,k]
            Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam)
            Hasil[i]=Hasil[i]-(Hasil[k]*lam)

print(&quot;Matrix A : &quot;,'\n',Matrix)

#Subtitution
x=np.zeros(n,float)
for m in range(n-1,-1,-1):
    x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m]
    print('Nilai X ',m+1, '=',x[m])
</code></pre>

<pre><code class="python">Masukkan ukuran Matrix: 3
Masukkan Nilai: 2
Masukkan Nilai: -2
Masukkan Nilai: 5
Masukkan Nilai: 1
Masukkan Nilai: 5
Masukkan Nilai: 2
Masukkan Nilai: 4
Masukkan Nilai: 5
Masukkan Nilai: 2
Masukkan Hasil: 12
Masukkan Hasil: 3
Masukkan Hasil: -4
Matrix A :  
 [[ 2.   -2.    5.  ]
 [ 0.    6.   -0.5 ]
 [ 0.    0.   -7.25]]
Nilai X  3 = 3.2413793103448274
Nilai X  2 = -0.2298850574712644
Nilai X  1 = -2.333333333333332
</code></pre>

<p>Panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel.</p>
<p>|2 -2 5|=|12|</p>
<p>|1 5 2|=| 3 |</p>
<p>|4 5 2|=|-4|</p>
<p>pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan</p>
<p>x1 = -2.333333333</p>
<p>x2 = -0.22988505</p>
<p>x3 = 3.2413793</p>
<h3 id="eliminasi-gauss-jacobi">Eliminasi Gauss Jacobi</h3>
<p>​       Metode ini merupakan suatu teknik penyelesaian SPL berukuran <em>n x n</em>, <em>AX</em> = <em>b</em>, secara <em>iteratif</em>. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, <em>X0</em>, kemudian membentuk suatu serangkaian vector <em>X1</em>, <em>X2</em>, … yang konvergen ke <em>X</em>.</p>
<p>​       Teknik <em>iteratif</em> jarang digunakan untuk menyelesaikan SPL berukuran kecil karena  metode-metode langsung seperti metode <em>eliminasi Gauss</em> lebih efisien dari pada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan persentase elemen nol pada matriks koefisien besar, teknik iteratif lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Metode <em>iterasi Jacobi</em>, prinsipnya: merupakan metode iteratif yang melakuakn perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan, <em>successive substitution</em>).</p>
<p><strong>Program</strong></p>
<pre><code class="python">from pprint import pprint
from numpy import array, zeros, diag, diagflat, dot
import numpy as np

def jacobi(A,b,N=25,x=None):
        #Membuat iniial guess                                                             
    if x is None:
        x = zeros(len(A[0]))

    #Membuat vektor dari elemen matrix A
    D = diag(A)
    R = A - diagflat(D)

    #Iterasi                                                                             
    for i in range(N):
        x = (b - dot(R,x)) / D
    return x

Mat1 = []
Mat2 = []

n = int(input(&quot;Masukkan ukuran Matrix: &quot;))
for i in range(n):
    baris=[]
    for i in range(n):
        a=int(input(&quot;Masukkan Nilai: &quot;))
        baris.append(a)
    Mat1.append(baris)
for i in range(n):
    h = int(input(&quot;Masukkan Hasil: &quot;))
    Mat2.append(h)

A = array(Mat1,float)
b = array(Mat2,float)
x=len(Mat1)
guess = np.zeros(x,float)

sol = jacobi(A,b,N=25,x=guess)

print(&quot;A:&quot;)
pprint(A)
print(&quot;b:&quot;)
pprint(b)
print(&quot;x:&quot;)
pprint(sol)
</code></pre>

<pre><code class="python">Masukkan ukuran Matrix: 3
Masukkan Nilai: 3
Masukkan Nilai: 1
Masukkan Nilai: -1
Masukkan Nilai: 4
Masukkan Nilai: 7
Masukkan Nilai: -3
Masukkan Nilai: 2
Masukkan Nilai: -2
Masukkan Nilai: 5
Masukkan Hasil: 5
Masukkan Hasil: 20
Masukkan Hasil: 10
A:
array([[ 3.,  1., -1.],
       [ 4.,  7., -3.],
       [ 2., -2.,  5.]])
b:
array([ 5., 20., 10.])
x:
array([1.50602413, 3.13253016, 2.6506024 ])
</code></pre>

<h3 id="eliminasi-gauss-seidel">Eliminasi Gauss Seidel</h3>
<p>​       Metode interasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah-ubah. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier .</p>
<p><strong>Program</strong></p>
<pre><code class="python">def seidel(a, x ,b): 
    #Mencari Panjang Matrix  
    n = len(a)               
    for j in range(0, n):        
        d = b[j]                 
        #Menghitung xi, yi, zi 
        for i in range(0, n):    
            if(j != i): 
                d-=a[j][i] * x[i]        
        x[j] = d / a[j][j] #Solusi   
    return x     

m=int(input(&quot;Masukkan Panjang Matrix: &quot;))
a=[]
b=[]
for k in range(m):
    mat1=[]
    for i in range(m):
        l=float(input(&quot;Masukkan a&quot;+str(k+1)+&quot;,&quot;+str(i+1)+&quot;: &quot;))
        mat1.append(l)
    h=float(input(&quot;Masukkan Hasil: &quot;))
    b.append(h)
    a.append(mat1)

n = 3                           
x = [0, 0, 0]                        
print(x) 

for i in range(0, 100):          
    x = seidel(a, x, b)
    print(x)                 
</code></pre>

<pre><code class="python">Masukkan Panjang Matrix: 3
Masukkan a1,1: 4
Masukkan a1,2: -1
Masukkan a1,3: 1
Masukkan Hasil: 7
Masukkan a2,1: 4
Masukkan a2,2: -8
Masukkan a2,3: 1
Masukkan Hasil: -21
Masukkan a3,1: -2
Masukkan a3,2: 1
Masukkan a3,3: 5
Masukkan Hasil: 15
[0, 0, 0]
[1.75, 3.5, 3.0]
[1.875, 3.9375, 2.9625]
[1.99375, 3.9921875, 2.9990625]
[1.99828125, 3.9990234375, 2.9995078125]
[1.99987890625, 3.9998779296875, 2.9999759765625003]
[1.99997548828125, 3.9999847412109375, 2.999993247070312]
[1.9999978735351562, 3.9999980926513667, 2.999999530883789]
[1.9999996404418945, 3.9999997615814205, 2.9999999038604734]
[1.9999999644302369, 3.9999999701976776, 2.9999999917325595]
[1.9999999946162794, 3.9999999962747097, 2.99999999859157]
[1.9999999994207849, 3.9999999995343387, 2.9999999998614464]
[1.9999999999182232, 3.999999999941793, 2.999999999978931]
[1.9999999999907154, 3.999999999992724, 2.9999999999977414]
[1.9999999999987457, 3.9999999999990905, 2.9999999999996803]
[1.9999999999998526, 3.9999999999998863, 2.9999999999999636]
[1.9999999999999807, 3.999999999999986, 2.999999999999995]
[1.9999999999999978, 3.9999999999999987, 2.9999999999999996]
[1.9999999999999996, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
[2.0, 4.0, 3.0]
</code></pre>

<p>Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3.</p>
<h2 id="recursive-trapezoid">Recursive Trapezoid</h2>
<p>Metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja. Maka dapat dituliskan persamaan sebagai berikut :</p>
<p><img alt="" src="persamaan1.png" /></p>
<p><strong>Algoritma Integral Trapezoida</strong></p>
<ol>
<li>
<p>Definisikan y = f(x)</p>
</li>
<li>
<p>Tentukan batas bawah (a) dan batas atas (b) integrasi</p>
</li>
<li>
<p>Tentukan jumlah pembagi n</p>
</li>
<li>
<p>Hitung h = (b-a)/2</p>
</li>
<li>
<p>Hitung</p>
</li>
</ol>
<p><img alt="" src="luas.png" /></p>
<p><strong>Program</strong></p>
<pre><code class="python">def fungsi (x):
    y = 1/(1+x)
    return y

print(&quot;fungsi yang digunakan adalah&quot;)
print(&quot;&quot;)
print(&quot;\t\t&quot;,&quot;f(x) = 1/(1+x)&quot;)
print(&quot;&quot;)


a = float(input(&quot;masukkan batas bawah integral : &quot;))
b = float(input(&quot;masukkan batas atas integral : &quot;))
c = int(input(&quot;masukkan n : &quot;))
eror = []
print(&quot;&quot;)
print(&quot;----------------Hasil Integrasi-----------------&quot;)
print (&quot;iterasi&quot;,&quot;\t&quot;,&quot;n&quot;,&quot;\t\t&quot;,&quot;Trapezoid&quot;)

for iterasi in range (0,c):
    n = 2**iterasi
    h = (b-a)/n

    xi = a
    y = 0
    for i in range (1,n):
        xi = xi + h
        y += fungsi(xi)
    trap = ((h)*(fungsi(a) + (2*y) + fungsi(b)))/2
    eror.append(trap)
    print (iterasi+1,&quot;\t\t&quot;,n,&quot;\t\t&quot;,trap)
print (eror[iterasi-1])
print(eror[iterasi])
hasil = (eror[iterasi-1]-eror[iterasi])
print(hasil)
print (&quot;estimasi error : &quot;+str(hasil))
</code></pre>

<pre><code class="python">fungsi yang digunakan adalah

         f(x) = 1/(1+x)

masukkan batas bawah integral : 1
masukkan batas atas integral : 3
masukkan n : 6

----------------Hasil Integrasi-----------------
iterasi      n       Trapezoid
1        1       0.75
2        2       0.7083333333333333
3        4       0.6970238095238095
4        8       0.6941218503718504
5        16          0.6933912022075267
6        32          0.6932082082692488
0.6933912022075267
0.6932082082692488
0.00018299393827792
estimasi error : 0.00018299393827792
</code></pre>

<p>Dari hasil output diatas dapat disimpulkan untuk fungsi f(x) = 1/(1+x) dengan batas bawah integral adalah 1 dan batas atasnya 3, dengan n = 6, proses iterasi menghasilkan estimasi error 0.00018299393827792.</p>
<h2 id="richardson-extrapolation">Richardson Extrapolation</h2>
<p>Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation digunakan untuk memperoleh hasil baru yang lebih akurat dari dua estimasi sebelumnya dengan menggunakan metode Integrasi Romberg sebagai salah satu cara untuk mengintegrasi secara efisien. Esktrapolasi Richardson menggunakan dua estimasi integrasi untuk menghitung estimasi ketiga yang lebih akurat.</p>
<p>Metode untuk memperoleh rumus hampiran turunan dengan orde yang lebih tinggi dari hampiran dengan orde yang lebih rendah disebut dengan ekstrapolasi. Metode tersebut dikembangkan oleh Lewis Fry Richardson di awal abad 20, sehingga metode tersebut kemudian dikenal dengan ekstrapolasi Richardson. Diterapkan pada turunan numerik untuk memperoleh solusi yang lebih baik <em>(improve).</em></p>
<ul>
<li><strong>Rumus :</strong></li>
</ul>
<p><strong>(f(x+h)−f(x−h))/(2h)</strong></p>
<p>untuk nilai h yang sangat kecil, dua fungsi evaluasi f(x+h) dan f(x−h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil.</p>
<p>Kita dapat mencoba untuk memperkirakan nilai tepat ee dengan perkiraan a(h). Dalam hal ini, ee adalah turunan dari f(1)(x) dan perkiraannya adalah (h)=(f(x+h)−f(x−h))/(2h). Misalkan sekarang kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor :</p>
<p><em>e=a(h)+Khn+o(hn)</em></p>
<p>Apabila menggunakan h/2 :</p>
<p><em>e=a(h/2)+K(h/2)n+o((h/2)n)</em></p>
<p><em>=a(h/2)+K/2nhn+o(hn)</em></p>
<p>Mengalikan kedua ekspresi ini dengan 2n dan mengurangi hasil persamaan pertama</p>
<p><em>2ne−e=2na(h/2)−a(h)+K/2nhn−Khn+o(hn)</em></p>
<p>Perhatikan bahwa istilah hnhn dibatalkan dan kita dibiarkan dengan</p>
<p><em>(2n−1)e=2na(h/2)−a(h)+o(hn)</em></p>
<p>Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knhn. Dapat kita tulis dengan :</p>
<p><em>K1=−1/6f(3)(x)h2,etc.</em></p>
<ul>
<li><strong>Program</strong></li>
</ul>
<pre><code class="python">from math import *
def zeros(n,m):
    Z=[]
    for i in range(n):
        Z.append([0]*m)
    return Z

def D(Func,a,h):
        return (Func(a+h)-Func(a-h))/(2*h)

def Richardson_dif(func,a):
    k=9 
    L=zeros(k,k)
    for I in range(k):
        L[I][0]=D(func,a,1/(2**(I+1)))
    for j in range(1,k):
        for i in range(k-j):
            L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1)
    return L[0][k-1]

print('~~~~~~~~~~~~~~~~~~~~~~Richardson Extrapolation~~~~~~~~~~~~~~~~~~~~~~')
print('SOAL\nf(x) = –0.1x4 – 0.15x3 – 0.5x2 – 0.25x + 1.2\n'
'Mulai dengan h1 = 0.5 dan h2 = 0.25, \nhitung estimasi dengan  f’(0.5) menggunakan Richardson Extrapolation')
print('============================')
print('f(x) = -0.1*x**4 - 0.15*x**3 - 0.5*x**2 - 0.25*x + 1.2 dengan x = 0.5')
print('HASIL = %04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5))
print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3))
</code></pre>

<pre><code class="python">~~~~~~~~~~~~~~~~~~~~~~Richardson Extrapolation~~~~~~~~~~~~~~~~~~~~~~
SOAL
f(x) = –0.1x4 – 0.15x3 – 0.5x2 – 0.25x + 1.2
Mulai dengan h1 = 0.5 dan h2 = 0.25, 
hitung estimasi dengan  f’(0.5) menggunakan Richardson Extrapolation
============================
f(x) = -0.1*x**4 - 0.15*x**3 - 0.5*x**2 - 0.25*x + 1.2 dengan x = 0.5
HASIL = -0.91250000000000530687
diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050
</code></pre>

<h2 id="metode-euler">Metode Euler</h2>
<p>​   Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah pemahamannya sehingga memudahkan dalam mempelajari metode lain yang lebih teliti.</p>
<p>Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Metode euler atau disebut juga metode orde pertama karena persamaannya kita hanya mengambil sampai suku orde pertama saja. Misalnya diberikan Persamaan Diferensial Biasa orde satu</p>
<p>y = dy/dx = f(x,y) dan nilai awal y(x0)=y0</p>
<p>Dengan langkah h didefinisikan sebagai</p>
<p>h = xn + 1 − xn</p>
<p>Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis</p>
<p><strong>yn + 1 = yn + f (xn,yn) h</strong></p>
<p>dimana n merupakan tahapan iterasi.</p>
<ul>
<li>Contoh Soal</li>
</ul>
<p>Gunakan metode Euler untuk menyelesaikan Persamaan Diferensial Biasa:</p>
<p>dy/dx = 1 + x2, y(1) = −4</p>
<p>Untuk menentukan y(1.01), y(1.02) dan y(1.03).</p>
<ul>
<li>Program</li>
</ul>
<pre><code class="python">print(&quot;f(x,y) = 1+x^2&quot;)
print(&quot;yn+1 = y1 + f (xn+yn) h&quot;)

x1 = float(input(&quot;Masukkan x1 = &quot;))

h = 0.01
n = 4 #jumlah x ada 4 yaitu (1, 1.01, 1.02, 1.03)
xi = -4
hasil = xi
y = 0
for i in range(n):
    print(&quot;hasil y&quot;+str(i)+&quot;= &quot;+ str(hasil))
    hasil = xi + h*(1+(x1+y)**2)
    y+=h
    xi = hasil
</code></pre>

<pre><code class="python">f(x,y) = 1+x^2
yn+1 = y1 + f (xn+yn) h
Masukkan x1 = 1
hasil y0= -4
hasil y1= -3.98
hasil y2= -3.959799
hasil y3= -3.9393949999999998
</code></pre>

<p>Dengan <strong>x1=1</strong> dan <strong>h=0.01</strong> masukkan rumus untuk mencari hasil dari <strong>y</strong> yang dicari, looping sebanyak n kali pada kasus diatas kita looping sebanyak <strong>4 kali</strong> karena yang dicari adalah <strong>1.01</strong>, <strong>1.02</strong>, <strong>1.03</strong> </p>
<h2 id="monte-carlo">Monte Carlo</h2>
<p>​   Simulasi monte carlo merupakan metode tipe simulasi probalistik dalam mencari penyelesaian masalah dengan sampling dari proses random atau acak. Sehingga dari hasil simulasi monte carlo dapat menentukan kebijakan yang menyangkut kondisi keputusan penyelesaian. Tujuan simulasi Monte carlo adalah menemukan nilai yang mendekati nilai sesungguhnya, atau nilai yang akan terjadi berdasarkan distribusi dari data sampling. Oleh sebab kemampuannya mampu memprediksi suatu nilai, maka Monte Carlo dahulu sering digunakan untuk kepentingan judi di kasino.</p>
<p>Tahapan dalam membuat simulasi metode monte carlo ialah dengan</p>
<ol>
<li>Membuat distribusi kemungkinan untuk variabel-variabel penting</li>
<li>Membangun distribusi kemungkinan kumulatif untuk tiap-tiap variabel pada tahap pertama</li>
<li>Menentukan interval bilangan acak (random) untuk tiap-tiap variabel</li>
<li>Membuat bilangan acak (random)</li>
<li>Membuat simulasi dari serangkaian percobaan</li>
</ol>
<p>Jika sebuah sistem mengandung unsur yang menunjukkan adanya peluang dalam perilaku mereka, maka simulasi metode <em>Monte Carlo</em> (<em>Monte Carlo method</em>) mungkin dapat diterapkan. Dasar simulasi <em>Monte Carlo</em> adalah percobaan pada unsur peluang (atau bersifat probabilistik) dengan menggunakan pengambilan sampel secara acak. Jadi Metode <em>Monte Carlo</em> adalah sebuah teknik simulasi yang menggunakan unsur acak ketika terdapat peluang dalam perilakunya.</p>
<ul>
<li>Contoh Soal</li>
</ul>
<p><img alt="" src="monte carlo soal.png" /></p>
<pre><code class="python">from scipy import random
import numpy as np
import matplotlib.pyplot as plt

a = 0
b = 2
N = 2500

#function for integral
def func(x):
    return (4-x**2)**0.5

area = []
for i in range(N):
    xrand = np.zeros(N)

    for i in range(len(xrand)):
        xrand[i] = random.uniform(a,b)
        integral = 0.0

    for i in range(N):
        integral+=func(xrand[i])

    jawab = (b-a)/float(N)*integral
    area.append(jawab)

plt.title(&quot;Nilai phi&quot;)
plt.hist(area,bins = 30, ec = 'black')
plt.xlabel(&quot;Area&quot;)
plt.show()
</code></pre>

<p><img alt="" src="carlo1.png" /></p>
<p><img alt="" src="carlo2.png" /></p>
<p>Kesimpulannya, dari kedua output percobaan diatas memiliki hasil yang berbeda namun kedua hasil percobaan tidak jauh dari angka 3.14</p>
<pre><code class="python">from scipy import random
import numpy as np

a = -1
b = 1
N=100
n=3
xrand=np.zeros(N)
yrand=np.zeros(N)
zrand=np.zeros(N)
integral=0.0
for i in range(n+1):
    for i in range(len(xrand)):
        xrand[i]=random.uniform(a,b)

    for i in range(len(yrand)):
        yrand[i]=random.uniform(a,b)

    for i in range(len(zrand)):
        zrand[i]=random.uniform(a,b)

    def func(x,y,z):
        return (x**2)+(y**2)+(z**2)


    for i in range(N):
        integral+=func(xrand[i],yrand[i],zrand[i])

jawab=(b-a)/float(N)*integral
print(&quot;Hasil : &quot;,jawab)
</code></pre>

<pre><code class="python">Hasil : 7.8547836963764235
Hasil : 8.183478456174651
Hasil : 8.032245667000106
</code></pre>

<p>Lalu kita bandingkan ke-3 hasil percobaan diatas dengan hitung manual</p>
<p><img alt="" src="carlo nih.jpg" /></p>
<p>Kesimpulannya, jika kita bandingkan hasil program dengan hasil hitung manual jawaban hampir mendekati</p>
<h2 id="ujian-akhir-semester">Ujian Akhir Semester</h2>
<p><img alt="" src="SoalUAS.png" /></p>
<ul>
<li>No. 1</li>
</ul>
<p><code>python
  from math import exp
  def midpoint(f, a, b, n):
      h = 0.1
      result = 0
      for i in range(n):
          result += f((a + h/2.0) + i*h)
      result *= h
      return result
  g = lambda y: exp(1+(2*a*a)+b)
  a = 0.1
  b = 0.3
  print ('    n        midpoint   ')
  for i in range(1, 21):
      n = 2**i
      m = midpoint(g, a, b, n)
      print ('%7d %.16f ' % (n, m))</code></p>
<p><code>python
      n        midpoint   
        2 0.7486842754521725 
        4 1.4973685509043451 
        8 2.9947371018086901 
       16 5.9894742036173829 
       32 11.9789484072347587 
       64 23.9578968144695068 
      128 47.9157936289390065 
      256 95.8315872578786809 
      512 191.6631745157554008 
     1024 383.3263490315084709 
     2048 766.6526980630579828 
     4096 1533.3053961261632594 
     8192 3066.6107922523738125 
    16384 6133.2215845020191409 
    32768 12266.4431690120054554 
    65536 24532.8863380336115370 
   131072 49065.7726760768273380 
   262144 98131.5453521632589400 
   524288 196263.0907014935219195 
  1048576 392526.1813997357385233</code></p>
<ul>
<li>No. 2</li>
</ul>
<p>```python
  alpha = .8
  M = [[1, 2, 3],
      [2, 3, 3],
      [1, 1, 1],]</p>
<p>n = len(M)
  rj = [1.0/n for _ in range(n)]
  p = [1.0/n for _ in range(n)]
  iter = 1</p>
<p>for _ in range(4):
      p_old = [x for x in p]
      for i in range(n):
          pi = 0.0
          for j in range(n):
              pi += alpha * M[i][j] * p_old[j]
          pi += (1-alpha) * rj[i]
          p[i] = pi
      print("iterasi ke-",iter,"= ",p)
      iter += 1
  ```</p>
<p><code>python
  iterasi ke- 1 =  [1.6666666666666667, 2.2, 0.8666666666666667]
  iterasi ke- 2 =  [7.0, 10.093333333333335, 3.8533333333333335]
  iterasi ke- 3 =  [31.064000000000007, 44.73866666666668, 16.824000000000005]
  iterasi ke- 4 =  [136.87733333333338, 197.51946666666674, 74.16800000000002]</code></p>
<ul>
<li>No. 3</li>
</ul>
<p><code>python
  def fungsi(x):
      y=2*x
      return y
  print ("Fungsi yang digunakan adalah f(x)=2*x")
  hasileksak=0.693147180
  a=float(input("masukkan batas bawah integral:"))
  b=float(input("masukkan batas atas integral:"))
  print("")
  print("----------------Hasil Integrasi-----------------")
  print ("iterasi","\t","n","\t","trapezoid")
  for iterasi in range(1,16,1):
      n=2*iterasi
      h=(b-a)/n
      xi=a
      y=0
      for i in range (1,n):
          xi=xi+h
          y+=fungsi(xi)
      It=(h)*((fungsi(a)+(2*y)+fungsi(b))/2)
      jmlganjil=0
      jmlgenap=0
      xi=a+h
      xj=a+(2*h)
      print (iterasi,"\t""\t",n,"\t",It)</code></p>
<p>```python
  Fungasi yang digunakan adalah f(x)=2*x
  masukkan batas bawah integral:1
  masukkan batas atas integral:3</p>
<p>----------------Hasil Integrasi-----------------
  iterasi   n    trapezoid
  1             2    8.0
  2             4    8.0
  3             6    8.0
  4             8    8.0
  5             10   8.0
  6             12   8.0
  7             14   7.999999999999998
  8             16   8.0
  9             18   8.000000000000004
  10            20   8.000000000000004
  11            22   7.999999999999995
  12            24   7.999999999999998
  13            26   8.0
  14            28   8.0
  15            30   8.000000000000002
  ```</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = ".",
                shortcuts = {"search": 83, "next": 78, "help": 191, "previous": 80};
        </script>
        <script src="js/base.js" defer></script>
        <script src="search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

<!--
MkDocs version : 1.0.4
Build Date UTC : 2020-06-25 10:52:27
-->
